---
layout: post
title: 分布式课程课后问题
author: lyeeer
---

关于分布式计算环境课程老师布置的课后问题


# 分布式课程课后问题
-------------------------
0325
## 1.什么是Java AIO、NIO、BIO？
一个IO操作可以分为两个步骤：发起IO请求和实际的IO操作

首先理清楚阻塞的概念：阻塞调用是指调用结果返回之前，当前线程会被挂起，函数只有在得到结果之后才会返回。

非阻塞是指不能立即得到结果之前，该函数只有在得到结果之后才会返回。参考一篇博文，觉得这个概念会很清晰“你先干，我先看看有没有其他事，你完事了告诉我”

阻塞与非阻塞IO区别在于第一步：发起IO请求是否会被阻塞，若阻塞直到完成就是阻塞IO.

同步与异步IO区别在于第二个步骤是否阻塞：针对应用程序和内核的交互而言，同步就是用户进程触发IO操作并等待或轮询地去查看IO操作是否就绪；异步就是用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。

同步和异步是目的，阻塞和非阻塞是实现方式

再来进行组合：
### 同步阻塞IO（BIO）：
服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

适用于连接数目比较小且固定的架构

### 同步非阻塞IO（NIO）：
服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器

### 异步非阻塞（AIO）
服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.

适用于连接数目多且连接比较多（重操作）的架构，比如相册服务器

异步不会再去区分阻塞非阻塞，对于用户进程，接到异步通知后，就直接操作进程用户态空间里的数据即可。

## 2.搭建Apache Thrift环境并编写同步和异常Helloworld例子 





-------------------------
0408
## 1.为什么会有软件危机？/如何实现软件开发中的摩尔定律？

## 2.什么是软件协同开发？





-------------------------
0417
## 1.熟悉Java语言的反射机制

在运行状态中，允许改变程序结构或变量类型，这种语言称为动态语言。虽然java不属于动态语言，但具有一个动态相关机制：reflection，即可以在运行时加载、探知、使用编译期间完全未知的class。

即在JVM运行期间通过查找到相应的类，通过类获取其属性以及方法来创造对象。

例如通过反射构造类：

​	1).Class clazz=Class.formName("com.tlc.Person");#通过class的静态方法获取对象

​	2).使用newInstance()或者newInstance（Object....params）创建实例



## 2.read "The rise and fall of CORBA"一文



Thanks to：<https://blog.csdn.net/dreamer23/article/details/80903978>
<https://bbym010.iteye.com/blog/2100868>

<https://blog.csdn.net/tanlicheng1/article/details/80625523>

